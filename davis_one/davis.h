
//This file was generated by davis_one_maker.py script.
//Use davis_files.txt and special comments to change generated davis.h and davis.cpp

#ifndef DAVIS_H_
#define DAVIS_H_

#include <algorithm>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <vector>
namespace dvs {
extern const char kAppName[];
extern const char kOutFolderName[];
extern const char kPlotlyJsName[];
extern const char kPlotlyJsResourcePath[];
extern const char kPlotlyJsWorkPath[];

} // namespace dvs end

namespace dv {

enum class conf_visualizationTypes {
  AUTO, //if user not forces some specific type it will be recognized by context
  CHART,
  HEATMAP,
  SURFACE
};

enum class conf_colorscales {
  DEFAULT,
  SUNNY,
  GLAMOUR,
  THERMAL,
  GRAYSCALE
};


struct commonSettings {
  commonSettings(): typeVisual(conf_visualizationTypes::AUTO), xLabel("X"), yLabel("Y") {}
  conf_visualizationTypes typeVisual;
  std::string xLabel;
  std::string yLabel;
};

struct chartSettings {

};

struct heatMapSettings {
  heatMapSettings(): colorSc(conf_colorscales::DEFAULT) {}
  conf_colorscales colorSc;
};

struct surfaceSettings {
  surfaceSettings(): colorSc(conf_colorscales::DEFAULT), zLabel("Z") {}
  conf_colorscales colorSc;
  std::string zLabel;
};


class Configurator {
 public:
  static Configurator& getInstance() {
    static Configurator instance;
    return instance;
  }
  Configurator(Configurator const&)   = delete;
  void operator=(Configurator const&) = delete;

  void reset() { //to default settings
    common = commonSettings();
    chart = chartSettings();
    heatmap = heatMapSettings();
    surf = surfaceSettings();
  };

  commonSettings common;
  chartSettings chart;
  heatMapSettings heatmap;
  surfaceSettings surf;

 private:
  Configurator() {};

};

Configurator& config();


} // namespace dv end
namespace dvs {
extern const char kCommonHeadPart[];
extern const char kDivSizePart[];
extern const char kColorMapDefaultPart[];
extern const char kColorMapSunnyPart[];
extern const char kColorMapGlamourPart[];
extern const char kColorMapThermalPart[];
extern const char kColorMapGrayscalePart[];
extern const char kHeatMapTypePart[];
extern const char kSurfaceTypePart[];
extern const char kCommonLastPart[];

} // namespace dvs end

namespace dvs {
using std::string;
using std::vector;

string getCurrentPath();

bool isPlotlyScriptExists();

bool saveStringToFile(const string& file_name,
                      const string& data);

void mayBeCreateJsWorkingFolder();

void sleepMs(unsigned long milisec);

void openPlotlyHtml(const string& file_name);

bool getDataFromFile(const string& path, string& result);

vector<string> split(const string& target, char c);

bool readMatrix(vector<vector<double>>& outMatrix, const string& path, char dlmtr);


bool make_string(const string& src,
                 const vector<string>& args,
                 string& out);

// Now it doesn't work.
bool deleteFolder(const char* fname);


} // namespace dvs end

namespace dvs {

using std::string;
using std::vector;
using std::istringstream;


bool createHtmlPageWithPlotlyJS(const vector<vector<double>>& values,
                                string& page, const dv::conf_visualizationTypes& type);

bool showHeatMapInBrowser(const vector<vector<double>>& values, const string& title);

bool showHeatMapInBrowser(const string& values, const string& title);

bool showLineChartInBrowser(const vector<double>& values, const string& title);

bool showLineChartInBrowser(const string& values, const string& title);

bool showSurfaceInBrowser(const vector<vector<double>>& values, const string& title);

bool showSurfaceInBrowser(const string& values, const string& title);

} // namespace dvs end

namespace dv {



using std::vector;
using std::string;


//! two-dimensional vector
template <typename T>
bool show(const vector<vector<T>>& data, const string& htmlPageName = dvs::kAppName);

//! two-dimensional array
template <typename T>
bool show(T** data, uint64_t arrRows, uint64_t arrCols,
          const string& htmlPageName = dvs::kAppName);

//! a one-dimensional array that simulates a two-dimensional one (element access [i*cols+j])
template <typename T>
bool show(const T* data, uint64_t arrRows, uint64_t arrCols,
          const string& htmlPageName = dvs::kAppName);

//! one-dimensional vector
template <typename T>
bool show(const vector<T>& data, const string& htmlPageName = dvs::kAppName);

//! one-dimensional array
template <typename T>
bool show(const T* data, uint64_t count, const string& htmlPageName = dvs::kAppName);

// ***********************************
// template functions implementations:
// ***********************************

template <typename T>
bool show(const vector<vector<T>>& data, const string& htmlPageName) {
  vector<vector<double>> vecVecDbl;
  vecVecDbl.reserve(data.size());
  for (vector<T> row : data) {
    vector<double> dblRow(row.begin(), row.end());
    vecVecDbl.emplace_back(dblRow);
  }
  bool res = false;
  if (config().common.typeVisual == conf_visualizationTypes::AUTO ||
      config().common.typeVisual == conf_visualizationTypes::HEATMAP)
    res = dvs::showHeatMapInBrowser(vecVecDbl, htmlPageName);
  else if (config().common.typeVisual == conf_visualizationTypes::SURFACE)
    res = dvs::showSurfaceInBrowser(vecVecDbl, htmlPageName);
  return res;
}

template <typename T>
bool show(T** data, uint64_t arrRows, uint64_t arrCols, const string& htmlPageName) {
  vector<vector<double>> vecVecDbl;
  vecVecDbl.reserve(arrRows);
  for (uint64_t i = 0; i < arrRows; ++i) {
    vector<double> dblRow(&data[i][0], &data[i][0] + arrCols);
    vecVecDbl.emplace_back(dblRow);
  }
  bool res = false;
  if (config().common.typeVisual == conf_visualizationTypes::AUTO ||
      config().common.typeVisual == conf_visualizationTypes::HEATMAP)
    res = dvs::showHeatMapInBrowser(vecVecDbl, htmlPageName);
  else if (config().common.typeVisual == conf_visualizationTypes::SURFACE)
    res = dvs::showSurfaceInBrowser(vecVecDbl, htmlPageName);
  return res;
}

template <typename T>
bool show(const T* data, uint64_t arrRows, uint64_t arrCols, const string& htmlPageName) {
  vector<vector<double>> vecVecDbl;
  vecVecDbl.reserve(arrRows);
  for (uint64_t i = 0; i < arrRows; ++i) {
    vector<double> dblRow(&data[i * arrCols], &data[i * arrCols] + arrCols);
    vecVecDbl.emplace_back(dblRow);
  }
  bool res = false;
  if (config().common.typeVisual == conf_visualizationTypes::AUTO ||
      config().common.typeVisual == conf_visualizationTypes::HEATMAP)
    res = dvs::showHeatMapInBrowser(vecVecDbl, htmlPageName);
  else if (config().common.typeVisual == conf_visualizationTypes::SURFACE)
    res = dvs::showSurfaceInBrowser(vecVecDbl, htmlPageName);
  return res;
}

template <typename T>
bool show(const vector<T>& data, const string& htmlPageName) {
  vector<double> dblRow(data.begin(), data.end());
  bool res = false;
  if (config().common.typeVisual == conf_visualizationTypes::AUTO ||
      config().common.typeVisual == conf_visualizationTypes::CHART)
    res = dvs::showLineChartInBrowser(dblRow, htmlPageName);
  return res;
}

template <typename T>
bool show(const T* data, uint64_t count, const string& htmlPageName) {
  vector<double> dblRow(data, data + count);
  bool res = false;
  if (config().common.typeVisual == conf_visualizationTypes::AUTO ||
      config().common.typeVisual == conf_visualizationTypes::CHART)
    res = dvs::showLineChartInBrowser(dblRow, htmlPageName);
  return res;
}

} // namespace dv end

#endif // DAVIS_H_